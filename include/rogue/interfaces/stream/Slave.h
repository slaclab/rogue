/**
 * ----------------------------------------------------------------------------
 * Company    : SLAC National Accelerator Laboratory
 * ----------------------------------------------------------------------------
 * Description:
 * Stream interface slave
 * ----------------------------------------------------------------------------
 * This file is part of the rogue software platform. It is subject to
 * the license terms in the LICENSE.txt file found in the top-level directory
 * of this distribution and at:
 *    https://confluence.slac.stanford.edu/display/ppareg/LICENSE.html.
 * No part of the rogue software platform, including this file, may be
 * copied, modified, propagated, or distributed except according to the terms
 * contained in the LICENSE.txt file.
 * ----------------------------------------------------------------------------
 **/
#ifndef __ROGUE_INTERFACES_STREAM_SLAVE_H__
#define __ROGUE_INTERFACES_STREAM_SLAVE_H__
#include "rogue/Directives.h"

#include <stdint.h>

#include <memory>
#include <string>
#include <thread>

#include "rogue/EnableSharedFromThis.h"
#include "rogue/Logging.h"
#include "rogue/interfaces/stream/Pool.h"

#ifndef NO_PYTHON
    #include <boost/python.hpp>
#endif

namespace rogue {
namespace interfaces {
namespace stream {

class Frame;
class Buffer;
class Master;

//! Stream slave class
/** The stream slave accepts stream data from a master. It also
 * can accept frame allocation requests through its Pool base class.
 * A Slave object can be attached to multiple Master objects.
 */
class Slave : public rogue::interfaces::stream::Pool,
              public rogue::EnableSharedFromThis<rogue::interfaces::stream::Slave> {
    // Mutex
    std::mutex mtx_;

    // Debug control
    uint32_t debug_;
    std::shared_ptr<rogue::Logging> log_;

    // Counters
    uint64_t frameCount_;
    uint64_t frameBytes_;

  public:
    //! Class factory which returns a pointer to a Slave (SlavePtr)
    /** Create a new Slave
     *
     * Exposed as rogue.interfaces.stream.Slave() to Python
     */
    static std::shared_ptr<rogue::interfaces::stream::Slave> create();

    // Setup class for use in python
    static void setup_python();

    // Class creator
    Slave();

    // Destroy the object
    virtual ~Slave();

    //! Shut down any threads associated with this object
    /** This method is called to stop any frames from being generated by this Master and
     *  shut down any threads, allowing for a clean program exit
     *
     *  Exposed as stop() to Python
     *  Subclasses should override this method
     */
    virtual void stop();

    //! Set debug message size
    /** This method enables debug messages when using the base Slave class
     * attached as a primary or secondary Slave on a Master. Typically used
     * when attaching a base Slave object for debug purposes.
     *
     * Exposed as setDebug() to Python
     * @param debug Maximum number of bytes to print in debug message.
     * @param name Name to included in the debug messages.
     */
    void setDebug(uint32_t debug, std::string name);

    //! Accept a frame from master
    /** This method is called by the Master object to which this Slave is attached when
     * passing a Frame. By default this method will print debug information if enabled
     * and is typically re-implemented by a Slave sub-class.
     *
     * Re-implemented as _acceptFrame() in a Python subclass
     * @param frame Frame pointer (FramePtr)
     */
    virtual void acceptFrame(std::shared_ptr<rogue::interfaces::stream::Frame> frame);

    //! Get frame counter
    /** Returns the total frames received. Only valid if acceptFrame is not re-implemented
     * as a sub-class. Typically used when attaching a base Slave object for debug purposes.
     *
     * Exposed as getFrameCount() to Python
     * @return Total number of Frame objects received.
     */
    uint64_t getFrameCount();

    //! Get byte counter
    /** Returns the total bytes received. Only valid if acceptFrame is not re-implemented
     * as a sub-class. Typically used when attaching a base Slave object for debug purposes.
     *
     * Exposed as getByteCount() to Python
     * @return Total number of bytes received.
     */
    uint64_t getByteCount();

    //! Ensure frame is a single buffer
    /** This method makes sure the passed frame is composed of a single buffer.
     *  If the reqNew flag is true and the passed frame is not a single buffer, a
     *  new frame will be requested and the frame data will be copied, with the passed
     *  frame pointer being updated. The return value will indicate if the frame is a
     *  single buffer at the end of the process. A frame lock must be held when this
     *  method is called.
     *
     * Not exposed to Python
     * @param frame Reference to frame pointer (FramePtr)
     * @param rewEn Flag to determine if a new frame should be requested
     */
    bool ensureSingleBuffer(std::shared_ptr<rogue::interfaces::stream::Frame>& frame, bool reqEn);

    // Process a local frame request
    /* Method to service a local frame request
     *
     * size Minimum size for requested Frame, larger Frame may be allocated
     * zeroCopyEn Flag which indicates if a zero copy mode Frame is allowed.
     * Newly allocated Frame pointer (FramePtr)
     */
    std::shared_ptr<rogue::interfaces::stream::Frame> reqLocalFrame(uint32_t size, bool zeroCopyEn);

#ifndef NO_PYTHON

    //! Support << operator in python
    boost::python::object lshiftPy(boost::python::object p);

#endif

    //! Support << operator in C++
    std::shared_ptr<rogue::interfaces::stream::Master>& operator<<(
        std::shared_ptr<rogue::interfaces::stream::Master>& other);
};

//! Alias for using shared pointer as SlavePtr
typedef std::shared_ptr<rogue::interfaces::stream::Slave> SlavePtr;

#ifndef NO_PYTHON

// Stream slave class, wrapper to enable python overload of virtual methods
class SlaveWrap : public rogue::interfaces::stream::Slave,
                  public boost::python::wrapper<rogue::interfaces::stream::Slave> {
  public:
    // Accept frame
    void acceptFrame(std::shared_ptr<rogue::interfaces::stream::Frame> frame);

    // Default accept frame call
    void defAcceptFrame(std::shared_ptr<rogue::interfaces::stream::Frame> frame);
};

typedef std::shared_ptr<rogue::interfaces::stream::SlaveWrap> SlaveWrapPtr;
#endif

}  // namespace stream
}  // namespace interfaces
}  // namespace rogue
#endif
